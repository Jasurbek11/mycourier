```md
# Техническое задание (ТЗ) для **mycourier** без использования Django

В данном документе описаны требования, архитектурные решения и структура проекта для системы **mycourier**, где бэкенд создаётся **без участия Django**, используя альтернативные технологии (например, **Flask** или **FastAPI**) и отдельные инструменты для миграций (Alembic и др.). Описывается подход с **чистым HTML/CSS** (и/или JavaScript-фреймворками на фронтенде), а также затрагивается вопрос, **стоит ли использовать микросервисы** или достаточно **монолитного** подхода.

---

## 1. Введение

**mycourier** – это система для:
1. Регистрации (онбординга) курьеров.
2. Управления статусами курьеров (активация, увольнение, блокировка).
3. Складского учёта (выдача/приём экипировки, утилизация).
4. Формирования аналитики (метрики, отчёты).
5. Административной панели (для управления данными и пользователями).
6. (Опционально) Телеграм-бот для службы безопасности (СБ) или других целей.

Главная цель – обеспечить гибкость, отказоустойчивость и удобство разработки **без** привязки к Django, используя **Flask**/**FastAPI** или аналогичные фреймворки (Python), самостоятельную настройку миграций БД (Alembic) и чёткое разделение фронтенда и бэкенда.

---

## 2. Выбор архитектуры: микросервисы или монолит

1. **Монолит**  
   - Подходит для **не очень крупного** проекта и команды.  
   - Все сервисы (онбординг, активация, склад, аналитика) размещаются в одном приложении (один кодовый базис).  
   - Проще развертывать и отлаживать, меньше оверхеда по сети и DevOps.

2. **Микросервисы**  
   - Подходящи для **больших команд**, где каждое направление (онбординг, склад, аналитика) может развиваться **отдельно** и масштабироваться независимо.  
   - Сложнее в конфигурации и DevOps (каждый сервис – отдельный деплой, своя БД или своя схема), но даёт гибкость и масштабируемость при высоких нагрузках.  
   - Требует механизмов межсервисной коммуникации (REST/gRPC, брокеры сообщений).

**Рекомендация:** Если проект **не планируется** разделять на множество независимых команд и модули не станут очень большими, начните с **монолита** (Flask/FastAPI). При росте объёмов можно **вынести** сервисы в отдельные репозитории (микросервисы).

---

## 3. Общие требования

1. **Хранение и редактирование данных курьеров**  
   - ФИО, телефон, ПИНФЛ, тип передвижения (пеший, авто и т. д.), статус документов, лог-партнёр.
2. **Статусы**: активация, увольнение, блокировка и т. д.
3. **Складской учёт**: выдача/приём экипировки, утилизация, перемещение по филиалам.
4. **Аналитика**: метрики (активные/уволенные курьеры), отчёты по складу, фильтрация по лог-партнёрам, регионам.
5. **Административная панель**  
   - Веб-интерфейс (Flask-Admin, FastAPI Admin, React/Vue/Admin Template) для управления моделями.
6. **Телеграм-бот** (опционально): поиск по курьерам, формирование PDF/Doc (если нужно).
7. **Миграции БД**: должны работать без удаления старых данных; при добавлении столбцов сохранять уже имеющиеся данные.

---

## 4. Технологический стек (без Django)

1. **Бэкенд**:
   - **Python** + **Flask** (либо **FastAPI** – более современный, поддержка асинхронного кода).  
   - **ORM**: SQLAlchemy (для Flask) или встроенный в FastAPI (через SQLAlchemy) для работы с PostgreSQL/MySQL.  
   - **Alembic** для миграций. Гарантирует безболезненное добавление/изменение столбцов, перенос данных, не затрагивая имеющиеся записи.  
   - **Flask-Admin** (если нужен быстрый админ-интерфейс) или **FastAPI Admin** (аналог).

2. **Фронтенд**:  
   - **HTML/CSS** + JS (Vanilla или React/Vue) – на выбор.  
   - При использовании Admin-шаблонов (React Admin, Vue Admin) – отдельное приложение, общающееся с бэкендом по REST/GraphQL.  
   - Если хотим «простой» фронт – чистые `.html` + `.css` + AJAX/Fetch запросы к REST API.

3. **База данных**:  
   - **PostgreSQL** (рекомендуется), MySQL или любая другая SQL-БД, поддерживающая SQLAlchemy.

4. **Контейнеризация**:  
   - **Docker** для упрощения сборки/развёртывания.  
   - (Опционально) Kubernetes (Helm) при масштабировании.

5. **Авторизация / Аутентификация**:
   - JWT или OAuth2 (Flask-JWT-Extended, FastAPI JWT auth).  
   - Хранение пользователей, ролей в таблице `users`.

---

## 5. Структура проекта (Senior-уровень)

Допустим, выбрали **монолит** на **FastAPI** c PostgreSQL.  
*(Если хотим микросервисы, делим логику по отдельным репозиториям/папкам, но структура остаётся похожей.)*

```plaintext
mycourier/
├── .env                         # Переменные окружения (DB_URL, JWT_SECRET, ...)
├── .gitignore
├── README.md                    # Описание проекта, инструкции
├── requirements.txt             # Python-зависимости
├── Makefile                     # (Опционально) команды build/run/test
├── Dockerfile                   # Сборка Docker-образа (бэкенда)
├── docker-compose.yml           # Для локального запуска (бэкенд + PostgreSQL + фронт-сервер)
├── ci-cd/                       # Скрипты и конфиги CI/CD (GitHub Actions, GitLab CI, Jenkins)
│   ├── github-actions.yml
│   └── ...
├── docs/                        # Техническая документация, схемы, ER-диаграммы
│   ├── architecture.md
│   ├── migrations_plan.md       # Описания стратегий миграций Alembic
│   └── ...
├── migrations/                  # Скрипты Alembic
│   ├── env.py
│   ├── versions/
│   │   ├── some_migration.py
│   │   └── ...
│   └── README.md
├── src/
│   ├── main.py                  # Точка входа FastAPI/Flask (app initialization)
│   ├── config.py                # Загрузка .env, общие настройки
│   ├── database.py              # Подключение к БД, engine, session
│   ├── models/                  # SQLAlchemy модели
│   │   ├── courier.py
│   │   ├── user.py
│   │   └── ...
│   ├── routers/                 # Роуты (endpoints)
│   │   ├── onboarding.py
│   │   ├── activation.py
│   │   ├── warehouse.py
│   │   └── analytics.py
│   ├── services/                # Бизнес-логика (доп. функции)
│   ├── schemas/                 # Pydantic-модели (для FastAPI), DTO и пр.
│   ├── admin/                   # Если Flask-Admin / FastAPI-Admin
│   └── ...
├── frontend/                    # Фронтенд (HTML/CSS/JS) или React/Vue
│   ├── index.html
│   ├── onboarding.html
│   ├── css/
│   ├── js/
│   └── ...
└── kubernetes/                  # (Опционально) Манифесты деплоя в K8s
    ├── deployment.yaml
    ├── service.yaml
    └── ...
```

### Пояснения

1. **`migrations/`**:  
   - Содержит файлы Alembic, позволяющие добавлять новые столбцы и таблицы без потери данных.  
   - Каждый раз при изменении моделей SQLAlchemy – генерируем новую миграцию (`alembic revision --autogenerate -m "Add field"`), затем `alembic upgrade head`.

2. **`src/`**:  
   - `main.py` запускает приложение FastAPI/Flask, регистрирует роуты.  
   - `models/` – SQLAlchemy модели (Courier, User, WarehouseItem и т.д.).  
   - `routers/` (или `controllers/`): файлы с эндпоинтами, например `onboarding.py`.  
   - `services/` – реализация бизнес-логики (методы выдачи экипировки, смены статуса и т.д.), чтобы не перегружать роуты.  
   - `schemas/` – Pydantic-схемы (FastAPI) или DTO (Flask-Marshmallow), валидация входных/выходных данных.

3. **Admin-панель**  
   - Либо используем `Flask-Admin`/`Flask-Admin-Plus` (если Flask), или `fastapi-admin` для FastAPI.  
   - Размещаем в `src/admin/` файл с конфигурацией (подключение моделей, настройка UI).

4. **Frontend**  
   - Если нужен чистый HTML/CSS/JS, кладём `.html` файлы, стили, скрипты; можем обслуживать их Nginx или любым статик-сервером.  
   - При желании React/Vue – тогда `package.json`, папка `src` для компонентов, сборка Webpack/Vite.

---

## 6. Механизмы миграций без удаления данных

- **Alembic** (для SQLAlchemy):  
  - Позволяет генерировать **версионные** скрипты миграций, где описано, как добавляется/изменяется/удаляется столбец/таблица.  
  - При добавлении столбца указываем значение по умолчанию или `nullable=True`, чтобы не нарушить имеющиеся данные.  
  - Пример: `alembic revision --autogenerate -m "Add transport_number to courier"` → создаст скрипт, изменяющий таблицу `couriers`.  
  - `alembic upgrade head` применит изменения без потери существующих записей.

- **Резервные копии**:  
  - На production-системе желательно делать бэкапы БД перед применением миграций.  
  - При ошибках можно откатиться (`alembic downgrade`), не теряя данных.

- **Совместимость**:  
  - Желательно иметь согласованный процесс dev/test/prod, чтобы новые поля корректно обрабатывались кодом сервисов.

---

## 7. Отказоустойчивость и масштабирование

1. **Горизонтальное масштабирование**:  
   - Поднимать несколько экземпляров приложения (gunicorn/uvicorn + FastAPI) за load balancer (NGINX, AWS ELB и т.д.).  
2. **PostgreSQL** репликация** или использование Managed DB (RDS, CloudSQL) для отказоустойчивости.  
3. **Если микросервисы** – каждый сервис (онбординг, склад, аналитика) может иметь свою БД (или схему), общаться по REST/gRPC.

---

## 8. CI/CD

1. **Сборка Docker-образа**:  
   - Копируем код из `src/`, устанавливаем зависимости из `requirements.txt`.  
   - Запускаем Gunicorn/Uvicorn (FastAPI) или waitress/gunicorn (Flask).
2. **Автотесты** (unit + integration) в пайплайне.  
3. **Alembic миграции** автоматически применяются ( `alembic upgrade head` ) при деплое, без удаления данных.  
4. **Blue-Green** / **Canary deployment** в Kubernetes или на виртуальных машинах – чтобы избежать простоев.

---

## 9. Роли и доступ (RBAC)

1. **Владелец** – полный доступ, управление сотрудниками, глобальные настройки.  
2. **Руководитель (склада, активаторов, лог-партнёров)** – видит только свои участки, метрики, курьеров, склад.  
3. **Сотрудник онбординга** – создаёт/редактирует курьеров, но не удаляет.  
4. **Сотрудник склада** – выдаёт/принимает экипировку.  
5. **СБ** – Телеграм-бот (расширенный поиск).  
6. **Админ-панель** – может быть общим UI (Flask-Admin) или отдельным фронтом (React Admin).

*(Логика проверки прав – в сервисном коде. Если нужно детальное разграничение, используем библиотеки вроде flask-security, fastapi-users и т.д.)*

---

## 10. Пример рабочего процесса (Roadmap)

1. **Определяем модели** (Courier, User, Equipment и т.д.) в `models/`, настраиваем Alembic.  
2. **Пишем endpoints** (Flask Blueprints / FastAPI Routers):
   - `/api/onboarding/`: POST – создать курьера, GET – список.
   - `/api/activation/{courier_id}/activate`, `/api/activation/{courier_id}/fire` и т.д.
   - `/api/warehouse/...`, `/api/analytics/...`
3. **Админ-панель**: Настраиваем Flask-Admin (или fastapi-admin) – подключаем модели, задаём формы.  
4. **Фронтенд**: (HTML/CSS/JS) – запросы к REST API.  
5. **Миграции**: При добавлении полей (номер транспорта, марка авто) создаём ревизии Alembic, применяем.  
6. **DevOps**: docker-compose для локального теста, CI/CD pipeline (тесты, build образа, миграции, деплой).  
7. **Мониторинг** (опционально): Prometheus/Grafana, ELK/Loki для логов.

---

## 11. Критерии приёмки

1. **Проект без Django**: Flask или FastAPI, SQLAlchemy + Alembic для БД, миграций.  
2. **Админ-панель**: через Flask-Admin / fastapi-admin / или отдельный фронт (React Admin).  
3. **Надёжные миграции**: без удаления данных, допускающие добавление новых столбцов/таблиц.  
4. **Отказоустойчивость**: механизмы бэкапов, возможность горизонтального масштабирования.  
5. **RBAC**: ролевая система, позволяющая ограничивать доступ.  
6. **CI/CD**: автосборка Docker, тестирование, автоматизированный деплой, без даунтайма.  
7. **Фронтенд**: отделённый (чистый HTML/CSS/JS или SPA), общается по REST.

---

## 12. Заключение

**mycourier** может быть реализован **без Django** на любом современном Python-фреймворке (Flask/FastAPI) для большей гибкости и лёгкости. **Alembic** обеспечивает плавные миграции БД без удаления старых записей, что гарантирует сохранность данных. Развёртывание возможно в **монолитном** варианте для упрощения или в формате **микросервисов** (каждый модуль – отдельный сервис), если команда и проект крупные, и нужно независимое масштабирование. 

При соблюдении приведённой структуры и рекомендаций проект будет иметь **отказоустойчивую архитектуру**, удобную в поддержке и развёртывании, соответствующую **Senior**-уровню разработки. 
```
